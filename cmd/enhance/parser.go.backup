package enhance

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/lepinkainen/hermes/internal/content"
	"github.com/lepinkainen/hermes/internal/enrichment"
	fm "github.com/lepinkainen/hermes/internal/frontmatter"
	"github.com/lepinkainen/hermes/internal/importer/mediaids"
	"gopkg.in/yaml.v2"
)

// Note represents a parsed markdown note with YAML frontmatter.
type Note struct {
	// Frontmatter fields
	Title        string `yaml:"title"`
	Type         string `yaml:"type"` // "movie", "tv", or "game"
	Year         int    `yaml:"year"`
	IMDBID       string `yaml:"imdb_id,omitempty"`
	TMDBID       int    `yaml:"tmdb_id,omitempty"`
	LetterboxdID string `yaml:"letterboxd_id,omitempty"`
	SteamAppID   int    `yaml:"steam_appid,omitempty"`
	Seen         bool   `yaml:"seen,omitempty"`

	// Raw frontmatter and content
	RawFrontmatter map[string]interface{}
	OriginalBody   string
}

// parseNoteFile parses a markdown file and extracts frontmatter and content.
func parseNoteFile(filePath string) (*Note, error) {
	fileContent, err := readFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	note, err := parseNote(fileContent)
	if err != nil {
		return nil, err
	}

	// If title is missing, extract from filename
	if note.Title == "" {
		note.Title = extractTitleFromPath(filePath)
	}

	return note, nil
}

// parseNote parses markdown content with YAML frontmatter.
func parseNote(fileContent string) (*Note, error) {
	// Split frontmatter and body
	parts := strings.SplitN(fileContent, "---", 3)
	if len(parts) < 3 {
		return nil, fmt.Errorf("invalid markdown format: missing frontmatter delimiters")
	}

	frontmatterStr := parts[1]
	body := parts[2]

	// Parse frontmatter
	var frontmatter map[string]interface{}
	if err := yaml.Unmarshal([]byte(frontmatterStr), &frontmatter); err != nil {
		return nil, fmt.Errorf("failed to parse frontmatter: %w", err)
	}

	note := &Note{
		RawFrontmatter: frontmatter,
		OriginalBody:   strings.TrimSpace(body),
	}

	// Extract typed fields
	if title, ok := frontmatter["title"].(string); ok {
		note.Title = title
	}

	// Get type from tmdb_type field or detect from tags
	note.Type = fm.DetectMediaType(frontmatter)

	if year, ok := frontmatter["year"].(int); ok {
		note.Year = year
	}
	ids := mediaids.FromFrontmatter(frontmatter)
	note.IMDBID = ids.IMDBID
	note.TMDBID = ids.TMDBID
	note.LetterboxdID = ids.LetterboxdID
	if seen, ok := frontmatter["seen"].(bool); ok {
		note.Seen = seen
	}

	// Check for Steam AppID
	note.SteamAppID = fm.IntFromAny(frontmatter["steam_appid"])

	return note, nil
}

// HasTMDBData checks if the note already has TMDB data in both frontmatter and body.
// Returns true only if both TMDB ID exists in frontmatter AND content markers exist in body.
func (n *Note) HasTMDBData() bool {
	return n.TMDBID != 0 && content.HasTMDBContentMarkers(n.OriginalBody)
}

// NeedsCover checks if the note needs a cover image.
// Returns true if the cover field is missing or empty.
func (n *Note) NeedsCover() bool {
	cover, ok := n.RawFrontmatter["cover"]
	if !ok {
		return true
	}

	coverStr, ok := cover.(string)
	return !ok || coverStr == ""
}

// NeedsContent checks if the note needs TMDB content sections.
// Returns true if TMDB content markers are missing from the body.
func (n *Note) NeedsContent() bool {
	return !content.HasTMDBContentMarkers(n.OriginalBody)
}

// IsGame returns true if this note is detected as a game note.
func (n *Note) IsGame() bool {
	return n.Type == "game"
}

// HasSteamData checks if the note already has Steam data in both frontmatter and body.
// Returns true only if both Steam AppID exists in frontmatter AND content markers exist in body.
func (n *Note) HasSteamData() bool {
	return n.SteamAppID != 0 && content.HasSteamContentMarkers(n.OriginalBody)
}

// NeedsSteamContent checks if the note needs Steam content sections.
// Returns true if Steam content markers are missing from the body.
func (n *Note) NeedsSteamContent() bool {
	return !content.HasSteamContentMarkers(n.OriginalBody)
}

// AddTMDBData adds TMDB enrichment data to the note's frontmatter.
func (n *Note) AddTMDBData(tmdbData *enrichment.TMDBEnrichment) {
	if tmdbData == nil {
		return
	}

	n.RawFrontmatter["tmdb_id"] = tmdbData.TMDBID
	n.RawFrontmatter["tmdb_type"] = tmdbData.TMDBType

	if tmdbData.RuntimeMins > 0 {
		n.RawFrontmatter["runtime"] = tmdbData.RuntimeMins
	}

	if tmdbData.TotalEpisodes > 0 {
		n.RawFrontmatter["total_episodes"] = tmdbData.TotalEpisodes
	}

	if len(tmdbData.GenreTags) > 0 {
		// Merge with existing tags using shared utility
		existingTags := enrichment.TagsFromAny(n.RawFrontmatter["tags"])
		mergedTags := enrichment.MergeTags(existingTags, tmdbData.GenreTags)
		n.RawFrontmatter["tags"] = mergedTags
	}

	if tmdbData.CoverPath != "" {
		n.RawFrontmatter["cover"] = tmdbData.CoverPath
	}

	// Set finished flag for TV shows based on TMDB status
	if tmdbData.Finished != nil {
		n.RawFrontmatter["finished"] = *tmdbData.Finished
	}

	// Set seen flag if movie has any rating but seen field is not already set
	if !n.hasSeenField() && n.hasAnyRating() {
		n.RawFrontmatter["seen"] = true
	}
}

// AddSteamData adds Steam enrichment data to the note's frontmatter.
func (n *Note) AddSteamData(steamData *enrichment.SteamEnrichment) {
	if steamData == nil {
		return
	}

	n.RawFrontmatter["steam_appid"] = steamData.SteamAppID

	if len(steamData.GenreTags) > 0 {
		// Merge with existing tags using shared utility
		existingTags := enrichment.TagsFromAny(n.RawFrontmatter["tags"])
		mergedTags := enrichment.MergeTags(existingTags, steamData.GenreTags)
		n.RawFrontmatter["tags"] = mergedTags
	}

	if steamData.CoverPath != "" {
		n.RawFrontmatter["cover"] = steamData.CoverPath
	}

	if len(steamData.Developers) > 0 {
		n.RawFrontmatter["developers"] = steamData.Developers
	}

	if len(steamData.Publishers) > 0 {
		n.RawFrontmatter["publishers"] = steamData.Publishers
	}

	if steamData.ReleaseDate != "" {
		n.RawFrontmatter["release_date"] = steamData.ReleaseDate
	}

	if steamData.MetacriticScore > 0 {
		n.RawFrontmatter["metacritic_score"] = steamData.MetacriticScore
	}
}

// BuildMarkdown builds the complete markdown content with updated frontmatter and content.
func (n *Note) BuildMarkdown(originalContent string, tmdbData *enrichment.TMDBEnrichment, overwrite bool) string {
	var sb strings.Builder

	// Write frontmatter
	sb.WriteString("---\n")
	frontmatterBytes, err := yaml.Marshal(n.RawFrontmatter)
	if err != nil {
		// Fallback to original if marshaling fails
		return originalContent
	}
	sb.Write(frontmatterBytes)
	sb.WriteString("---\n\n")

	// Handle TMDB content with marker-based replacement
	body := n.OriginalBody
	if tmdbData != nil && tmdbData.ContentMarkdown != "" {
		if content.HasTMDBContentMarkers(body) {
			// Replace existing TMDB content between markers
			if overwrite {
				body = content.ReplaceTMDBContent(body, tmdbData.ContentMarkdown)
			}
		} else {
			// No markers exist - append wrapped content
			wrappedContent := content.WrapWithMarkers(tmdbData.ContentMarkdown)
			body = strings.TrimRight(body, "\n")
			if body != "" {
				body += "\n\n"
			}
			body += wrappedContent
		}
	}

	sb.WriteString(body)
	return sb.String()
}

// BuildMarkdownForSteam builds the complete markdown content with updated frontmatter and Steam content.
func (n *Note) BuildMarkdownForSteam(originalContent string, steamData *enrichment.SteamEnrichment, overwrite bool) string {
	var sb strings.Builder

	// Write frontmatter
	sb.WriteString("---\n")
	frontmatterBytes, err := yaml.Marshal(n.RawFrontmatter)
	if err != nil {
		// Fallback to original if marshaling fails
		return originalContent
	}
	sb.Write(frontmatterBytes)
	sb.WriteString("---\n\n")

	// Handle Steam content with marker-based replacement
	body := n.OriginalBody
	if steamData != nil && steamData.ContentMarkdown != "" {
		if content.HasSteamContentMarkers(body) {
			// Replace existing Steam content between markers
			if overwrite {
				body = content.ReplaceSteamContent(body, steamData.ContentMarkdown)
			}
		} else {
			// No markers exist - append wrapped content
			wrappedContent := content.WrapWithSteamMarkers(steamData.ContentMarkdown)
			body = strings.TrimRight(body, "\n")
			if body != "" {
				body += "\n\n"
			}
			body += wrappedContent
		}
	}

	sb.WriteString(body)
	return sb.String()
}

// readFile is a helper to read file content.
// This is separate for easier testing/mocking if needed.
func readFile(path string) (string, error) {
	fileContent, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(fileContent), nil
}

// extractTitleFromPath extracts a title from the file path.
// For example: "/path/to/Lilo & Stitch.md" -> "Lilo & Stitch"
func extractTitleFromPath(filePath string) string {
	// Get the base filename
	filename := filepath.Base(filePath)
	// Remove the .md extension
	title := strings.TrimSuffix(filename, filepath.Ext(filename))
	return title
}

// GetMediaIDs extracts all external media IDs from the frontmatter.
// Returns a struct containing any TMDB, IMDB, or Letterboxd IDs found.
func (n *Note) GetMediaIDs() mediaids.MediaIDs {
	return mediaids.MediaIDs{
		TMDBID:       n.TMDBID,
		IMDBID:       n.IMDBID,
		LetterboxdID: n.LetterboxdID,
	}
}

// HasAnyID checks if the note has any external ID (TMDB, IMDB, or Letterboxd).
// Returns true if at least one ID is present and non-empty.
func (n *Note) HasAnyID() bool {
	return n.GetMediaIDs().HasAny()
}

// GetIDSummary returns a formatted string summary of all available IDs.
// Useful for logging and debugging.
func (n *Note) GetIDSummary() string {
	return n.GetMediaIDs().Summary()
}

// hasSeenField checks if the note already has a seen field in frontmatter.
func (n *Note) hasSeenField() bool {
	_, exists := n.RawFrontmatter["seen"]
	return exists
}

// hasAnyRating checks if the note has any rating field (imdb_rating, my_rating, or letterboxd_rating).
func (n *Note) hasAnyRating() bool {
	// Check for IMDb rating
	if imdbRating, ok := n.RawFrontmatter["imdb_rating"]; ok {
		if rating, isFloat := imdbRating.(float64); isFloat && rating > 0 {
			return true
		}
		if rating, isInt := imdbRating.(int); isInt && rating > 0 {
			return true
		}
	}

	// Check for my_rating
	if myRating, ok := n.RawFrontmatter["my_rating"]; ok {
		if rating, isInt := myRating.(int); isInt && rating > 0 {
			return true
		}
		if rating, isFloat := myRating.(float64); isFloat && rating > 0 {
			return true
		}
	}

	// Check for letterboxd_rating
	if letterboxdRating, ok := n.RawFrontmatter["letterboxd_rating"]; ok {
		if rating, isFloat := letterboxdRating.(float64); isFloat && rating > 0 {
			return true
		}
		if rating, isInt := letterboxdRating.(int); isInt && rating > 0 {
			return true
		}
	}

	return false
}
